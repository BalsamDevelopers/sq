<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Search Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e2e8f0;
        }
        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), 1fr);
            gap: 2px;
            width: fit-content;
            margin: auto;
            border: 2px solid #64748b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
        }
        .grid-cell {
            width: 3rem;
            height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 600;
            background-color: #f1f5f9;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            user-select: none;
            border-radius: 0.25rem;
        }
        .selected {
            background-color: #cbd5e1;
            transform: scale(1.05);
        }
        .found {
            background-color: #86efac;
            color: #166534;
            font-weight: bold;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
        .word-list li {
            font-size: 1.25rem;
            color: #475569;
            transition: color 0.2s ease-in-out;
        }
        .word-found {
            text-decoration: line-through;
            color: #94a3b8;
        }
        .message-box {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @media (max-width: 640px) {
            .grid-cell {
                width: 2rem;
                height: 2rem;
                font-size: 1.2rem;
            }
            .word-list li {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body class="bg-gray-200 min-h-screen flex flex-col items-center justify-center p-4">
    <div class="bg-white p-8 rounded-2xl shadow-xl max-w-4xl w-full flex flex-col items-center">
        <h1 class="text-4xl font-bold text-gray-800 mb-6 text-center">Word Search Puzzle</h1>
        <p id="message-box" class="text-lg font-semibold text-green-700 h-8 mb-4"></p>
        <div id="puzzle-container" class="mb-8">
            <div id="puzzle-grid" class="puzzle-grid"></div>
        </div>
        <div class="flex flex-col md:flex-row gap-8 w-full justify-between items-start">
            <div class="w-full md:w-1/2">
                <h2 class="text-2xl font-semibold text-gray-700 mb-4">Words to Find:</h2>
                <ul id="word-list" class="word-list grid grid-cols-2 sm:grid-cols-3 md:grid-cols-2 lg:grid-cols-3 gap-2"></ul>
            </div>
            <div class="w-full md:w-1/2 flex justify-center">
                <button id="reset-button" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:bg-indigo-700 transition duration-300 transform hover:scale-105 active:scale-95">
                    Reset Puzzle
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        // Word sets for different puzzles
        const wordSets = [
            ['MORNING', 'EVENING', 'FRIEND', 'HAPPY', 'WATER', 'FOOD', 'HOME'],
            ['SUNSHINE', 'OCEAN', 'FOREST', 'RIVER', 'MOUNTAIN', 'ISLAND', 'WIND'],
            ['SCIENCE', 'UNIVERSE', 'GENETIC', 'PLANET', 'GRAVITY', 'ENERGY', 'LIGHT'],
            ['FOOTBALL', 'SOCCER', 'BASKETBALL', 'TENNIS', 'SWIMMING', 'HOCKEY', 'RUGBY'],
            ['TRAVEL', 'JOURNEY', 'ADVENTURE', 'EXPLORE', 'TOURIST', 'VILLAGE', 'GLOBAL'],
            ['EAGLE', 'FALCON', 'SPARROW', 'ROBIN', 'PIGEON', 'TURKEY', 'RAVEN'],
            ['PYTHON', 'JAVASCRIPT', 'REACT', 'ANGULAR', 'PYTHON', 'HTML', 'MYSQL'],
            ['COMPUTERS', 'KEYBOARD', 'MONITOR', 'HARDWARE', 'SOFTWARE', 'NETWORK', 'SERVER'],
            ['SUMMER', 'AUTUMN', 'WINTER', 'SPRING', 'HOLIDAY', 'VACATION', 'SEASONS'],
            ['PLANTS', 'FLOWER', 'LEAF', 'ROOTS', 'BRANCH', 'PETAL', 'TRUNK'],
            ['FRUITS', 'ORANGE', 'BANANA', 'APPLE', 'GRAPE', 'PEACH', 'CHERRY'],
            ['FAMILY', 'MOTHER', 'FATHER', 'SISTER', 'BROTHER', 'AUNT', 'UNCLE'],
            ['ANIMALS', 'TIGER', 'LION', 'ZEBRA', 'BEAR', 'WOLF', 'ELEPHANT'],
            ['SCHOOL', 'STUDENT', 'TEACHER', 'LESSON', 'PENCIL', 'CRAYON', 'PAPER'],
            ['MUSIC', 'GUITAR', 'PIANO', 'DRUMS', 'SONG', 'MELODY', 'RHYTHM'],
            ['WEATHER', 'CLOUDY', 'SUNNY', 'STORMY', 'WINDY', 'SNOWY', 'FOGGY'],
            ['SPORTS', 'PLAYER', 'SCORE', 'GOAL', 'TEAM', 'COACH', 'MEDAL'],
            ['CITIES', 'LONDON', 'PARIS', 'ROME', 'TOKYO', 'SYDNEY', 'DUBAI'],
            ['FOODS', 'PIZZA', 'BURGER', 'BREAD', 'PASTA', 'RICE', 'SALAD'],
            ['BODY', 'HANDS', 'ARMS', 'LEGS', 'HEAD', 'CHEST', 'FEET'],
            ['COLORS', 'PURPLE', 'ORANGE', 'YELLOW', 'GREEN', 'BLACK', 'WHITE'],
            ['JOBS', 'DOCTOR', 'NURSE', 'PILOT', 'CHEF', 'WRITER', 'ENGINEER'],
            ['CLOTHES', 'SHIRT', 'PANTS', 'SOCKS', 'JACKET', 'SHOES', 'COAT'],
            ['NATURE', 'LAKE', 'OCEAN', 'DESERT', 'FOREST', 'VALLEY', 'CANYON'],
            ['VEHICLES', 'CARGO', 'BUSES', 'TRAINS', 'TRUCKS', 'PLANE', 'BOATS'],
            ['EMOTIONS', 'ANGRY', 'HAPPY', 'SADNESS', 'FEAR', 'EXCITED', 'CALM'],
            ['SPACE', 'PLANET', 'STARS', 'COMET', 'GALAXY', 'ORBIT', 'ASTEROID'],
            ['HOLIDAYS', 'EASTER', 'CHRISTMAS', 'HALLOWEEN', 'BIRTHDAY', 'THANKSGIVING', 'VACATION'],
            ['GAMES', 'PUZZLE', 'CHESS', 'CARDS', 'BOARD', 'PLAYER', 'SCORE'],
            ['DRINKS', 'JUICE', 'SODA', 'WATER', 'MILK', 'COFFEE', 'TEA'],
            ['BUILDINGS', 'CASTLE', 'CHURCH', 'MOSQUE', 'PALACE', 'TOWER', 'MUSEUM'],
            ['HOBBIES', 'READING', 'WRITING', 'SINGING', 'DANCING', 'PAINTING', 'HIKING'],
            ['SPICES', 'PEPPER', 'SALT', 'CUMIN', 'BASIL', 'OREGANO', 'THYME'],
            ['ANIMALS', 'RABBIT', 'SQUIRREL', 'DEER', 'FOX', 'BEAVER', 'RACCOON'],
            ['FURNITURE', 'CHAIR', 'TABLE', 'SOFA', 'DESK', 'DRESSER', 'SHELF'],
            ['PROFESSIONS', 'TEACHER', 'POLICE', 'ARTIST', 'DENTIST', 'FARMER', 'JUDGE'],
            ['GEOGRAPHY', 'RIVER', 'OCEAN', 'DESERT', 'VOLCANO', 'GLACIER', 'ISLAND'],
            ['FANTASY', 'DRAGON', 'WIZARD', 'GNOME', 'ORC', 'FAIRY', 'TROLL'],
            ['TECHNOLOGY', 'ROBOT', 'COMPUTER', 'INTERNET', 'PHONE', 'LAPTOP', 'PRINTER'],
            ['MEDICAL', 'DOCTOR', 'NURSE', 'SURGERY', 'HOSPITAL', 'PATIENT', 'THERAPY'],
            ['SCIENCE', 'ATOMS', 'PROTON', 'ELECTRON', 'NEURON', 'GENE', 'CELLS'],
            ['SPORTS', 'HOCKEY', 'RUGBY', 'TENNIS', 'BOXING', 'SWIMMING', 'GOLF'],
            ['DESSERTS', 'CAKE', 'PIE', 'COOKIES', 'SUNDAE', 'PUDDING', 'CUSTARD'],
            ['LITERATURE', 'NOVEL', 'POEM', 'STORY', 'FICTION', 'DRAMA', 'PLAY'],
            ['VEGETABLES', 'CARROT', 'ONION', 'POTATO', 'CABBAGE', 'SPINACH', 'TOMATO'],
            ['TRANSPORT', 'AIRPORT', 'TRAFFIC', 'SUBWAY', 'HELICOPTER', 'BICYCLE', 'SCOOTER'],
            ['CELEBRATIONS', 'PARTY', 'FESTIVAL', 'BIRTHDAY', 'WEDDING', 'ANNIVERSARY', 'CONGRATS'],
            ['ART', 'PAINTING', 'SCULPTURE', 'DRAWING', 'MURAL', 'CANVAS', 'SKETCH'],
            ['MONEY', 'WALLET', 'DOLLAR', 'CURRENCY', 'BANK', 'COINS', 'BUDGET'],
            ['TOOLS', 'HAMMER', 'WRENCH', 'PLIERS', 'SAW', 'DRILL', 'SCREWDRIVER']
        ];
        
        let words = []; // This will hold the current set of words
        const gridSize = 12; // Must be large enough to contain all words
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // --- Global State ---
        let grid = [];
        let foundWords = new Set();
        let isSelecting = false;
        let selectedCells = [];
        let startCell = null;
        let endCell = null;

        // --- DOM Elements ---
        const puzzleGrid = document.getElementById('puzzle-grid');
        const wordList = document.getElementById('word-list');
        const messageBox = document.getElementById('message-box');
        const resetButton = document.getElementById('reset-button');

        // --- Utility Functions ---

        /**
         * Generates a random letter from the alphabet.
         * @returns {string} A random uppercase letter.
         */
        function getRandomLetter() {
            return alphabet[Math.floor(Math.random() * alphabet.length)];
        }

        /**
         * Generates the initial empty grid.
         */
        function generateEmptyGrid() {
            const newGrid = [];
            for (let i = 0; i < gridSize; i++) {
                newGrid[i] = new Array(gridSize).fill('');
            }
            return newGrid;
        }

        /**
         * Checks if a word can be placed at a specific position.
         * @param {string} word - The word to place.
         * @param {number} row - Starting row.
         * @param {number} col - Starting column.
         * @param {number} dr - Row direction (-1, 0, 1).
         * @param {number} dc - Column direction (-1, 0, 1).
         * @returns {boolean} True if the word fits, false otherwise.
         */
        function canPlaceWord(word, row, col, dr, dc) {
            const wordLength = word.length;
            for (let i = 0; i < wordLength; i++) {
                const r = row + i * dr;
                const c = col + i * dc;
                if (r < 0 || r >= gridSize || c < 0 || c >= gridSize || (grid[r][c] !== '' && grid[r][c] !== word[i])) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Places a single word onto the grid.
         * @param {string} word - The word to place.
         */
        function placeWord(word) {
            const directions = [
                [0, 1], [0, -1], [1, 0], [-1, 0], // Horizontal & Vertical
                [1, 1], [1, -1], [-1, 1], [-1, -1] // Diagonal
            ];

            let placed = false;
            let attempts = 0;
            const maxAttempts = 100;

            while (!placed && attempts < maxAttempts) {
                const row = Math.floor(Math.random() * gridSize);
                const col = Math.floor(Math.random() * gridSize);
                const [dr, dc] = directions[Math.floor(Math.random() * directions.length)];

                if (canPlaceWord(word, row, col, dr, dc)) {
                    for (let i = 0; i < word.length; i++) {
                        const r = row + i * dr;
                        const c = col + i * dc;
                        grid[r][c] = word[i];
                    }
                    placed = true;
                }
                attempts++;
            }
        }

        /**
         * Populates the grid with words and then random letters.
         */
        function populateGrid() {
            grid = generateEmptyGrid();
            const shuffledWords = [...words].sort(() => Math.random() - 0.5);
            shuffledWords.forEach(word => placeWord(word));

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = getRandomLetter();
                    }
                }
            }
        }

        /**
         * Renders the puzzle grid on the page.
         */
        function renderPuzzle() {
            puzzleGrid.innerHTML = '';
            puzzleGrid.style.setProperty('--grid-size', gridSize);

            for (let r = 0; r < gridSize; r++) {
                for (let c = 0; c < gridSize; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell', 'rounded-lg');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.textContent = grid[r][c];
                    puzzleGrid.appendChild(cell);
                }
            }
        }

        /**
         * Renders the list of words to find.
         */
        function renderWordList() {
            wordList.innerHTML = '';
            words.forEach(word => {
                const li = document.createElement('li');
                li.id = `word-${word}`;
                li.textContent = word;
                li.classList.add('p-2', 'rounded-md', 'bg-gray-100', 'text-center', 'font-semibold', 'uppercase');
                if (foundWords.has(word)) {
                    li.classList.add('word-found');
                }
                wordList.appendChild(li);
            });
        }

        // --- Selection Logic ---

        /**
         * Gets the cell element at a given row and column.
         * @param {number} r - Row index.
         * @param {number} c - Column index.
         * @returns {HTMLElement | null} The cell element or null.
         */
        function getCell(r, c) {
            return document.querySelector(`.grid-cell[data-row='${r}'][data-col='${c}']`);
        }

        /**
         * Highlights the cells based on the current selection.
         */
        function highlightSelection() {
            // Clear existing highlights
            document.querySelectorAll('.grid-cell.selected').forEach(cell => cell.classList.remove('selected'));

            if (!startCell || !endCell) return;

            const startR = parseInt(startCell.dataset.row);
            const startC = parseInt(startCell.dataset.col);
            const endR = parseInt(endCell.dataset.row);
            const endC = parseInt(endCell.dataset.col);

            const dRow = endR - startR;
            const dCol = endC - startC;
            const length = Math.max(Math.abs(dRow), Math.abs(dCol));

            selectedCells = [];
            if (length === 0) {
                selectedCells.push(startCell);
            } else if (Math.abs(dRow) === Math.abs(dCol) || dRow === 0 || dCol === 0) {
                // Diagonal, horizontal, or vertical selection
                const dr = dRow === 0 ? 0 : dRow / Math.abs(dRow);
                const dc = dCol === 0 ? 0 : dCol / Math.abs(dCol);

                for (let i = 0; i <= length; i++) {
                    const cell = getCell(startR + i * dr, startC + i * dc);
                    if (cell) {
                        selectedCells.push(cell);
                    }
                }
            }

            selectedCells.forEach(cell => cell.classList.add('selected'));
        }

        /**
         * Checks if the selected cells form a valid word.
         */
        function checkWord() {
            if (selectedCells.length < 2) return;

            const selectedLetters = selectedCells.map(cell => cell.textContent).join('');
            
            const reversedLetters = selectedCells.reverse().map(cell => cell.textContent).join('');
            selectedCells.reverse(); // Restore original order

            const foundWord = words.find(word => word === selectedLetters || word === reversedLetters);

            if (foundWord && !foundWords.has(foundWord)) {
                foundWords.add(foundWord);
                selectedCells.forEach(cell => {
                    cell.classList.remove('selected');
                    cell.classList.add('found');
                });
                const wordElement = document.getElementById(`word-${foundWord}`);
                if (wordElement) {
                    wordElement.classList.add('word-found');
                }
                showMessage(`Found: ${foundWord}!`, 'green');
                
                if (foundWords.size === words.length) {
                    setTimeout(() => showMessage('Puzzle Complete!', 'indigo'), 500);
                }
            }
        }

        /**
         * Displays a temporary message in the message box.
         * @param {string} text - The message to display.
         * @param {string} color - The color class ('green', 'red', 'indigo').
         */
        function showMessage(text, color) {
            messageBox.textContent = text;
            messageBox.className = `text-lg font-semibold h-8 mb-4 message-box text-${color}-700`;
            setTimeout(() => messageBox.textContent = '', 2000);
        }
        
        // --- Event Handlers ---

        function handleMouseDown(e) {
            const cell = e.target.closest('.grid-cell');
            if (cell && !cell.classList.contains('found')) {
                isSelecting = true;
                startCell = cell;
                endCell = cell;
                highlightSelection();
            }
        }

        function handleMouseMove(e) {
            if (!isSelecting) return;
            const cell = e.target.closest('.grid-cell');
            if (cell && cell !== endCell) {
                endCell = cell;
                highlightSelection();
            }
        }

        function handleMouseUp() {
            isSelecting = false;
            checkWord();
            // Clear selection highlight after checking
            document.querySelectorAll('.grid-cell.selected').forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];
            startCell = null;
            endCell = null;
        }

        function handleReset() {
            foundWords.clear();
            // Randomly select a new word set
            words = wordSets[Math.floor(Math.random() * wordSets.length)];
            populateGrid();
            renderPuzzle();
            renderWordList();
            showMessage('Puzzle Reset!', 'indigo');
        }

        // --- Main Initialization ---

        function init() {
            // Check for touch device to enable touch events
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            if (isTouchDevice) {
                puzzleGrid.addEventListener('touchstart', handleMouseDown);
                puzzleGrid.addEventListener('touchmove', handleMouseMove);
                puzzleGrid.addEventListener('touchend', handleMouseUp);
            } else {
                puzzleGrid.addEventListener('mousedown', handleMouseDown);
                puzzleGrid.addEventListener('mousemove', handleMouseMove);
                puzzleGrid.addEventListener('mouseup', handleMouseUp);
            }

            resetButton.addEventListener('click', handleReset);
            handleReset(); // Initial setup
        }

        window.onload = init;
    </script>
</body>
</html>
